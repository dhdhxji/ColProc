#ifndef BINDINGS_H
#define BINDINGS_H

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "LuaBridge/LuaBridge.h"
#include "LuaBridge/Vector.h"
#include "LuaBridge/List.h"
#include "LuaBridge/Map.h"

/*[[[cog
##############################
# Retrieve class information #
##############################

import json
import cog

def read_all(file_path: str):
    with open(file_path, 'r') as f:
        return f.read()

meta = json.loads(read_all(class_meta_path))

]]]*/
//[[[end]]]



/*[[[cog
###############################
# Include all library headers #
###############################

includes = set(c['headerPath'] for c in meta)
for include in includes:
    cog.outl(f'#include "{include}"')

]]]*/
//[[[end]]]


//TODO: filter class by allowed list

// Expand templated classes with all known templates args
/*[[[cog
###############
# DEFINITIONS #
###############

template_specs = {
    'Variable': (
        'int', 
        'int8_t', 'int16_t', 'int32_t', 'int64_t',
        'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
        'float', 'double',
        'char', 'bool'),

    'VariableCallback': (
        'int', 
        'int8_t', 'int16_t', 'int32_t', 'int64_t',
        'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
        'float', 'double',
        'char', 'bool'),

    'VariableConstant': (
        'int', 
        'int8_t', 'int16_t', 'int32_t', 'int64_t',
        'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t',
        'float', 'double',
        'char', 'bool')
}

def is_template(typename: str) -> bool:
    return '<' in typename

def template_pure_name(typename: str) -> str:
    return typename.split('<')[0]

def template_spec_name(typename: str) -> str:
    res = '<'.join(typename.split('<')[1:])
    return ''.join(res.split('>'))

def spec_template(typename:str, ct_name: str, templ_arg: str):
    if template_spec_name(typename) == ct_name:
        return f'{template_pure_name(typename)}<{templ_arg}>'
    else:
        #it is already specified
        return typename

# Assuming that type is one word
def find_type_pos(tokens):
    qualifiers = ('const', 'volatile', 'static', '&', '*', '(', ')', '::', 'std', 'function', '<', '>')
    for i in range(len(tokens)):
        if tokens[i] not in qualifiers:
            return i

def get_pure_type(type_w_qualifiers: str) -> str:
    tokens = type_w_qualifiers.split()
    pos = find_type_pos(tokens)
    return tokens[pos]

def replace_type(type_w_qualifiers: str, new_type: str) ->str:
    tokens = type_w_qualifiers.split()
    pos = find_type_pos(tokens)
    tokens[pos] = new_type
    return ' '.join(tokens)


def gen_class_templates(class_meta, template_spec=template_specs):
    res = []
    
    ctempl_name = template_spec_name(class_meta['className'])
    for spec in template_spec[template_pure_name(class_meta['className'])]:
        c = class_meta.copy()
        c['constructors'] = c['constructors'].copy()
        c['methods'] = c['methods'].copy()
        if 'baseClass' in c.keys():
            c['baseClass'] = c['baseClass'].copy()

        c['className'] = spec_template(
            c['className'],
            ctempl_name,
            spec
        )

        if 'rootClass' in c.keys() and is_template(c['rootClass']):
            if template_spec_name(c['rootClass']) == ctempl_name:
                c['rootClass'] = spec_template(c['rootClass'],
                                               ctempl_name,
                                               spec)

        if 'baseClass' in c.keys():
            base_classes = []
            for base in c['baseClass']:
                if is_template(base):
                    if template_spec_name(base) == ctempl_name:
                        base_classes.append(spec_template(c['rootClass'],
                                                        ctempl_name,
                                                        spec)
                        )
                else:
                    base_classes.append(base)
            c['baseClass'] = base_classes
        
        for constr in c['constructors']:
            for arg in constr['arguments']:
                if is_template(arg):
                    arg['type'] = spec_template(
                        arg['type'], 
                        ctempl_name, 
                        spec
                    )

            for arg in constr['arguments']:
                if is_template(arg):
                    arg['type'] = spec_template(
                        arg['type'], 
                        ctempl_name, 
                        spec
                    )
                
                if get_pure_type(arg['type']) == ctempl_name:
                    arg['type'] = replace_type(arg['type'], spec)

        for method in c['methods']:
            if is_template(method['returnType']):
                method['returnType'] = spec_template(
                    method['returnType'],
                    ctempl_name,
                    spec
                )

            for arg in method['arguments']:
                if is_template(arg):
                    arg['type'] = spec_template(
                        arg['type'], 
                        ctempl_name, 
                        spec
                    )
                
                if get_pure_type(arg['type']) == ctempl_name:
                    arg['type'] = replace_type(arg['type'], spec)

        res.append(c)

    return res

def find_longest_public_constructor(constructors):
    l_constr = None

    for c in constructors:
        is_public = c['access'] == 'public'

        if l_constr == None and is_public:
            l_constr = c
            continue

        if len(c['arguments']) > len(l_constr['arguments']) and is_public:
            l_constr = c

    return l_constr

def bind_function_name(name):
    if name == 'operator==':
        return '__eq'
    elif name == 'operator+':
        return '__add'
    elif name == 'operator-':
        return '__sub'
    elif name == 'operator*':
        return '__mul'
    elif name == 'operator/':
        return '__div'
    elif name == 'operator%':
        return '__mod'
    else:
        return name
        
def untemplate(name):
    return name.replace("<", "_").replace(">", "")

]]]*/
//[[[end]]]


/*[[[cog
classes_to_bind = []
for c in meta:
    if is_template(c['className']):
        classes_to_bind = classes_to_bind + gen_class_templates(c)
    else:
        classes_to_bind.append(c)

]]]*/
//[[[end]]]


/*[[[cog
cog.outl(f'lua_State* {builder_fn_name}_build_lua_state() ')
]]]*/
//[[[end]]]
{
    lua_State* luaState = luaL_newstate();
    luaL_openlibs(luaState);

    luabridge::getGlobalNamespace(luaState)

    /*[[[cog
    ########################
    # Fill up binding code #
    ########################

    for c in classes_to_bind:
        if 'baseClass' in c.keys():
            cog.outl(f'.deriveClass<{c["className"]}, {c["baseClass"][0]}>("{untemplate(c["className"])}")')
        else:
            cog.outl(f'.beginClass<{c["className"]}>("{untemplate(c["className"])}")')
            
        constr = find_longest_public_constructor(c['constructors'])
        if constr is not None:
            cog.outl(f'.addConstructor<void(*)({ ", ".join([arg["type"] for arg in constr["arguments"]]) })>()')

        for m in c['methods']:
            if m['access'] != 'public':
                continue

            types = ', '.join(arg['type'] for arg in ({'type': m['returnType']}, *m['arguments']))
            cog.outl(f'.addFunction<{types}>("{bind_function_name(m["name"])}", &{c["className"]}::{m["name"]})')

        for f in c['fields']:
            if f['access'] != 'public':
                continue

            cog.outl(f'.addData<{f["type"]}>("{f["name"]}", &{c["className"]}::{f["name"]})')

        cog.outl('.endClass()')

    ]]]*/
    //[[[end]]]
    ;

    // Add Info about available classes/funcs/vars to lua

    return luaState;
}

#endif // BINDINGS_H

//Exclude     //.addConstructor<void(*)(size_t, size_t, strip_mode_t, rmt_channel_t, gpio_num_t)>()
